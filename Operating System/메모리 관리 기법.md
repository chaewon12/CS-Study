# 메모리 관리 기법

## 메모리 관리 기법이 왜 생겼을까?
- 프로그램의 크기와 복잡성이 증가함에 따라 메모리 관리의 중요성이 생겼다.
- 여러 개의 프로세스가 동시에 메모리에 적재가 된다면 자신만의 독립적인 메모리 공간이 필요로 하고 이를 효율적으로 할당하고 보호하기 위해 생겼다.

### 단편화
- 메모리 공간이 충분함에도 불구하고 프로세스가 메모리에 적재되지 못해 메모리가 낭비되는 현상을 말합니다.
- 외부 단편화 : 여유 공간이 충분함에도 불구하고 여유 공간들이 흩어져 있어 메모리에 프로세스가 적재하지 못하고 메모리가 낭비되는 현상
- 내부 단편화 : 프로세스가 실제 사용해야 할 메모리보다 더 큰 메모리가 할당 받아 메모리가 낭비되는 현상

### 연속 메모리 할당
- 페이징 기법과 세그먼테이션 기법과 같이 논리적인 분할 없이 연속된 물리 메모리 영역에 프로세스를 할당하는 방식입니다.
![image](https://github.com/sohn919/Algorithm/assets/84082544/77f5b62e-bc3e-4d06-ae4a-2393fa9e588a)
![image](https://github.com/sohn919/Algorithm/assets/84082544/0053c1df-aa50-496a-b114-ae8fd5fe70ca)
- 이와 같이 20MB 를 메모리에 할당해야 하는 상황에서 60MB 메모리 공간에 할당이 된다면 내부 단편화가 생기고 메모리를 효율적으로 사용하지 않게 됩니다.
![image](https://github.com/sohn919/Algorithm/assets/84082544/ae688478-1610-420f-8145-1b3f00c9e57b)
- 이와 같은 메모리 영역에서 50MB, 30MB, 100MB, 20MB 프로세스를 차례로 적재하게 된다면
![image](https://github.com/sohn919/Algorithm/assets/84082544/41003390-b9c6-4014-b6cd-ac6e07d53e8e)
- 이와 같이 메모리 영역을 잘 사용하게 되는데 이때 B와 D의 프로세스가 끝나게 된다면
![image](https://github.com/sohn919/Algorithm/assets/84082544/2dfb60e5-2a04-45b9-9514-b68d0439241a)
- 50MB의 빈 공간이 생겼음에도 불구하고 50MB를 사용할 수 없게 되는데 이를 외부 단편화라고 하며 메모리를 효율적으로 사용하지 않게 됩니다
- 이러한 이유로 연속 메모리 할당보다는 불연속 메모리 할당 기법인 페이징과 세그먼테이션 기법을 사용합니다.


### 페이징 기법
- 프로세스의 논리 주소 공간을 페이지라는 일정 단위로 자르고 메모리의 물리 주소 공간을 프레임이라는 페이지와 동일한 일정 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법입니다.
![image](https://github.com/sohn919/Algorithm/assets/84082544/a6572831-1d8b-4065-8e89-9a3ebf1d91a1)
- 이와 같은 형태로 페이지 테이블을 사용하여 논리 주소와 물리 주소를 맵핑하여 사용하게 됩니다.
![image](https://github.com/sohn919/Algorithm/assets/84082544/16c97307-f5fc-4af2-8ab1-28b92a5a3969)
- 이처럼 페이징 기법의 장점인 페이지 단위로 관리 하기 때문에 외부 단편화에서 벗어날 수 있게 됩니다.
![image](https://github.com/sohn919/Algorithm/assets/84082544/fa3dd6ef-4bc4-4c71-8e72-25f0363bf69f)
- 하지만 고정된 크기로 분할을 하였기에 그 크기보다 작게 사용하게 된다면 내부 단편화가 발생하게 되는 단점이 생깁니다.

### 세그먼테이션 기법
- 프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트(Segment)로 분할하여 메모리에 할당하는 기법이다.
- 페이징과 마찬가지로 맵핑을 위한 세그먼트 테이블을 사용합니다.
- 세그먼트들은 페이지와 달리 크기가 서로 다르기 때문에 메모리 적재될 때 빈 공간을 찾아 할당하게 됩니다.
- 이로 인해 내부 단편화에서 벗어날 수 있게 되지만 가변적인 크기로 인해 외부 단편화가 생기게 됩니다.

### 페이지 교체 알고리즘
- 제한된 메모리 용량으로 인해 페이지 교체가 일어나는데 이를 효율적으로 하기 위한 알고리즘이다.
- 페이지 부재 : 메모리에 적재된 페이지 중 사용 페이지가 없을 때를 의미한다.
![image](https://github.com/sohn919/Algorithm/assets/84082544/fc0d82ad-7368-4531-9bdc-0485c1494e2b)
- FIFO 알고리즘은 이름 그대로 가장 먼저 메모리에 올라온 페이지를 가장 먼저 내보내는 알고리즘이다

### Reference
- [페이지 교체 알고리즘](https://velog.io/@thdgusrbek/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4%EC%99%80-%ED%94%84%EB%A0%88%EC%9E%84-%ED%95%A0%EB%8B%B9)
